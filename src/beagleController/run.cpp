/*
Pitágoras Alves & André Winston, UFRN, March 2017.

string run(const char * command):
  command   Shell command to be executed by linux;
  returns   A string with all of the output generated by the command
string run(string command):
  same as above
void runWhileSilent(vector<string> commands):
  commands  Vector of commands to be executed in sequence. If one of the commands
            outputs anything, the commands after him will be canceled.
*/
#include "run.h"

void setScheduling(std::thread &th, int policy, int priority){
  sched_param sch_params;
  sch_params.sched_priority = priority;
  if(pthread_setschedparam(th.native_handle(), policy, &sch_params)) {
      std::cerr << "Failed to set Thread scheduling : " << std::strerror(errno) << std::endl;
  }
}

void runWhileSilent(vector<string> commands){
  string output;
  for(string cmd : commands){
    output = run(cmd);
    if(output.length() > 2){
      cout << output << endl;
      break;
    }
  }
}

string run(string command){
  return run(command.c_str());
}

string run(const char* command){
  int bufferSize = 128;
  char buff[bufferSize];
  string output = "";
  FILE *procStream = popen(command, "r");

  if(procStream == NULL){
    throw std::runtime_error("Could not get process output");
  }else{
    try{
      while (!feof(procStream)){
          if (fgets(buff, bufferSize, procStream) != NULL){
              output += buff;
          }
      }
    }catch(...){
      pclose(procStream);
      throw std::runtime_error("Error while getting output of process");
    }
    pclose(procStream);
    return output;
  }

}
